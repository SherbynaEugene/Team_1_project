Звіт до комп'ютерного проєкту:

Візуалізація: Поліна і Софія

Для візуалізації алгоритму ми використовували бібліотеку pygame. За допомогою неї можна легко робити анімації і тому подібне, що було для проєкту дуже корисним.
На віконці, яке випливає при запуску програми можна побачити граф з позначеними вершинами та ребра з їхньою вагою

Основні складові реалізації:
1. Позиціонування вершин графу
Функція node_position() розташовує вершини на екрані у вигляді дерева з використанням DFS. Відстані між вершинами адаптивно змінюються залежно від розміру графу, що забезпечує читаність для графів від 3 до 8+ вершин.

3. Відображення ребер та ваг
Ребра графу малюються з динамічною товщиною та кольором, залежно від рівня феромону:

Слабі феромони → чорні тонкі лінії
Сильні феромони → зелені товсті лінії

Ваги ребер відображаються синім текстом біля середини кожного ребра з урахуванням зміщення для читаності.

3. Анімація мурах під час ітерацій
Під час кожної ітерації алгоритму мурахи анімовано рухаються вздовж знайдених маршрутів. Червоні кружки представляють мурах, які поступово переміщуються від вершини до вершини з плавною інтерполяцією.

4. Відображення процесу пошуку
Кожна ітерація показується окремо з інформацією про номер ітерації. Тривалість відображення адаптивна: якщо мурахи не знайшли цикл, ітерація проходить швидше.

Через візуалізацію феромонів користувач може спостерігати:

- Як феромони накопичуються на найкоротших шляхах (збільшення товщини та інтенсивності зеленого кольору)
- Як випаровування феромонів впливає на менш перспективні маршрути
- Збіжність алгоритму до оптимального рішення протягом ітерацій

Фінальна анімація
Після завершення всіх ітерацій найкращий знайдений маршрут (Гамільтоновий цикл) виділяється золотистою лінією. П'ять мурах безперервно проходять цей оптимальний маршрут, що демонструє результат роботи алгоритму.

Деякі з функцій та ключових моментів візуалізації:

Функція node_position() реалізує адаптивне розташування вершин за допомогою рекурсивного DFS алгоритму. Ключові особливості:

Дерево-подібна структура: Вершини розташовуються по рівнях глибини, де корінь знаходиться в лівому верхньому куту
Динамічні відступи: Залежно від кількості вершин (≤4, ≤6, ≤8, >8) автоматично коригуються:

Горизонтальні відступи між сусідніми вершинами (sibling_spacing: 200 → 120)
Вертикальні відступи між рівнями (level_spacing: 180 → 100)

Функція draw_nodes() малює вершини у вигляді двох концентричних кіл:

Зовнішнє коло (чорне, радіус 30 пікселів) — основна форма
Внутрішнє коло (біле, радіус 27 пікселів) — фон для тексту
Номер вершини центрується всередині за допомогою розрахунку ширини та висоти шрифту

Функція draw_edges() — виконує кілька моментів:
а) Кодування феромонів кольором:
Значення феромону нижче порогу (≤0.11) → чорні лінії (товщина 2px)
Значення вище порогу → градієнт від чорного до зеленого на основі інтенсивності феромону
Формула: t = min(1.0, (феромон - 0.11) / 0.39) — нормалізує значення в діапазон [0, 1]
Розраховується значення зеленого каналу: g = int(255 * t)

б) Товщина:
Товщина лінії змінюється з феромоном: від 2px до 8px
Формула: thickness = int(2 + 6 * t) — забезпечує наочну різницю найпопулярніших маршрутів

в) Уникнення подвійного малювання:
Набір drawn зберігає вже намальовані ребра як відсортовані кортежи (min, max)
Це запобігає малюванню двох напрямків ненаправленого графу

г) Відображення ваг ребер:
Вага розміщується в середині ребра синім текстом
Використовується математичне зміщення перпендикулярно до лінії ребра:
Нормальний вектор: (-dy/length, dx/length)
Зміщення на 15 пікселів від лінії для читаності

Під час кожної ітерації алгоритму реалізована плавна анімація руху мурах:
а)Плавне переміщення мурах:
Для кожної мурахи розраховується прогрес progress = frame / animation_frames
На основі прогресу визначається поточне ребро та позиція на цьому ребрі
Рівняння для плавного переміщення мурах по вершинах:

  x = x1 + (x2 - x1) * t
  y = y1 + (y2 - y1) * t
б) Адаптивна тривалість:

Якщо мурахи знайшли цикл: 300 кадрів (5 секунд при 60 FPS)
Якщо цикл не знайдено: 120 кадрів (2 секунди)
Це дозволяє швидше переходити до наступної ітерації при невдачах

в) Відображення мурах:
Мурахи показуються червоними кружками (радіус 8px) під час ітерацій
Червоний колір контрастує з чорними вершинами та зеленими ребрами

5. Інформаційний дисплей
На кожному кадрі відображається поточна ітерація алгоритму білим текстом (шрифт 40pt) у верхньому лівому куту. Це дозволяє користувачеві стежити за прогресом алгоритму.

7. Фінальна анімація оптимального маршруту
Після завершення всіх ітерацій запускається друга частна візуалізації:
а) Виділення оптимального шляху:

Найкращий знайдений маршрут малюється золотистою лінією (товщина 7px)
Золотистий колір (255, 215, 0) добре помітний на білому тлі й відрізняється від феромонових ребер

б) Циклічна анімація мурах:

5 мурах рухаються вздовж оптимального маршруту в циклічному режимі
Кожна мураха має свій тимчасовий зміщення t = random.random() для несинхронного руху
При досягненні кінця маршруту мураха повертається на початок

Також, встановлено FPS-обмеження на 60 кадрів за секунду через clock.tick(60)
  


