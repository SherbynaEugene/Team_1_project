
**План роботи над комп'ютерним проєктом**

На зустрічах було обговорено:
* принципи використання Git і платформи GitHub.
* Створено та належним чином налаштовано спільний репозиторій для командної розробки.
* Розподілено обов'язки між учасниками команди та продумано етапи розробки проєкту.
* Кожен учасник отримав чітке завдання, виконання якого необхідне для реалізації алгоритму.

Ментор: 

Микита Ягода

Учасники та їх завдання:

Євгеній - Розробка базової частини коду та реалізація перевірки на гамільтонів цикл за теоремою Дірака

Ярина - Розробка додаткової функції перевірки зв'язності графу з допомогою пошуку вглиб

Софія - Візуалізація

Оля - Розробка додаткової функції перевірки зв'язності графу з допомогою пошуку вглиб

Поліна - Візуалізація





**Звіт по роботі над комп'ютерним проєктом по реалізації мурашиного алгоритму!**

Під час виконання цього проєкту ми вивчили принцип роботи мурашиного алгоритму та змогли спільними зусиллями реалізувати достатнью кількість додаткового функціоналу. Ми навчилися візуалізувати граф, працювати з феромонами, запускати мурашок у кількох ітераціях та аналізувати отримані результати.

**Кроки алгоритму ant_algorithm**

**1.** Перевірка на можливість існування Гамільтонового циклу

* Використовується спрощена перевірка за «Теоремою Дірака»: Якщо граф має ≥3 вершини, і кожна вершина з’єднана хоча б з n/2 іншими, теоретично може існувати Гамільтоновий цикл.
* Встановлюється прапорець dirak_theorem.

**2.** Ініціалізація графу

* Створюється словник weight, де вага кожного ребра це значення а ключ це саме ребро.
* Ініціалізується словник феромонів pheromone на всіх ребрах (початкове значення 0.1).
* Створюється словник edge_visits, щоб відслідковувати скільки разів кожне ребро пройдено.

**3.** Налаштування параметрів алгоритму

* alpha – важливість феромону.
* beta – важливість зворотної ваги (довжини ребра).
* evaporation – коефіцієнт випаровування феромону.

**4.** Визначення внутрішніх допоміжних функцій

* path_weight(path) – обчислює сумарну вагу пройденого мурашкою шляху.
* choose_next_vertice(current, visited) – вибір наступної вершини для мурашки на основі феромону та ваги ребер.
* ant_run(start) – проходження однієї мурашки від стартової вершини, повертає Гамільтоновий цикл або None.

**5.** Основний цикл ітерацій

* Для кожної ітерації (iterations):
    1. Виводиться поточний граф і номер ітерації.
    2. Ініціалізуються списки:
        * all_paths – збереження всіх шляхів мурашок.
        * paths_for_visual – шляхи для візуалізації.
        * found_cycles – кількість знайдених Гамільтонових циклів.
    3. Запуск мурашок
        * Для кожної мурашки (num_ants):
            1. Випадково обирається стартова вершина.
            2. Викликається ant_run(start) для побудови шляху.
            3. Якщо шлях знайдено, обчислюється його довжина (path_weight) і оновлюється найкращий шлях (best_path) та довжина                        (best_length).
            4. Якщо мурашка не знайшла шлях, у paths_for_visual зберігається лише стартова вершина.
    4. Оновлення феромонів
        * Спершу відбувається випаровування: всі феромони зменшуються на (1 - evaporation).
        * Потім кожна мурашка, яка знайшла шлях, відкладає феромон пропорційно довжині шляху: pheromone += 1 / length.
        * Одночасно оновлюється edge_visits.
    5. Виводяться оновлені феромони та інформація по ітерації.
    6. Повертається словник з поточними результатами ітерації через yield.

**6.** Після всіх ітерацій

* Виводиться найкращий знайдений Гамільтоновий цикл і його довжина.
* Якщо жодної мурашці не вдалося знайти цикл – виводиться повідомлення про відсутність циклу.



**Ключові моменти візуалізації:**

Для візуалізації алгоритму ми використовували бібліотеку pygame. За допомогою неї можна легко робити анімації і тому, що було для проєкту дуже корисним.
На віконці, яке випливає при запуску програми можна побачити граф з позначеними вершинами та ребра з їхньою вагою

**Основні складові реалізації:**
1. Позиціонування вершин графу
Функція node_position() розташовує вершини на екрані у вигляді дерева з використанням DFS. Відстані між вершинами адаптивно змінюються залежно від розміру графу, що забезпечує читаність для графів від 3 до 8+ вершин.

3. Відображення ребер та ваг
Ребра графу малюються з динамічною товщиною та кольором, залежно від рівня феромону:

Якщо слабкі феромони - чорні тонкі лінії

Якщо сильні феромони - зелені товсті лінії

Ваги ребер відображаються синім текстом біля середини кожного ребра з урахуванням зміщення для читаності.

3. Анімація мурах під час ітерацій
Під час кожної ітерації алгоритму мурахи анімовано рухаються вздовж знайдених маршрутів. Червоні кружки представляють мурах, які поступово переміщуються від вершини до вершини з плавним переміщенням.

4. Відображення процесу пошуку
Кожна ітерація показується окремо з інформацією про номер ітерації. Тривалість відображення адаптивна: якщо мурахи не знайшли цикл, ітерація проходить швидше.

Через візуалізацію феромонів користувач може спостерігати:

- Як феромони накопичуються на найкоротших шляхах (збільшення товщини та інтенсивності зеленого кольору)
- Як випаровування феромонів впливає на менш перспективні маршрути
- Збіжність алгоритму до оптимального рішення протягом ітерацій

Фінальна анімація
Після завершення всіх ітерацій найкращий знайдений маршрут (Гамільтоновий цикл) виділяється золотистою лінією. П'ять мурах безперервно проходять цей оптимальний маршру і демонструє результат роботи алгоритму.

**Деякі з функцій та ключових моментів візуалізації:**

Функція node_position() реалізує адаптивне розташування вершин за допомогою рекурсивного DFS алгоритму. Ключові особливості:

- вершини розташовуються по рівнях глибини, де корінь знаходиться в лівому верхньому куту
- залежно від кількості вершин (≤4, ≤6, ≤8, >8) автоматично коригуються:

1. горизонтальні відступи між сусідніми вершинами (sibling_spacing: 200 → 120).
2. вертикальні відступи між рівнями (level_spacing: 180 → 100)

Функція draw_nodes() малює вершини у вигляді двох концентричних кіл:

Зовнішнє коло (чорне, радіус 30 пікселів) — основна форма
Внутрішнє коло (біле, радіус 27 пікселів) — фон для тексту
Номер вершини центрується всередині за допомогою розрахунку ширини та висоти шрифту

Функція draw_edges() — виконує кілька моментів:
а) Кодування феромонів кольором:
Значення феромону нижче порогу (≤0.11) → чорні лінії (товщина 2px)
Значення вище порогу → градієнт від чорного до зеленого на основі інтенсивності феромону
Формула: t = min(1.0, (феромон - 0.11) / 0.39) — нормалізує значення в діапазон [0, 1]
Розраховується значення зеленого каналу: g = int(255 * t)

б) Товщина:
Товщина лінії змінюється з феромоном: від 2px до 8px
Формула: thickness = int(2 + 6 * t) — забезпечує наочну різницю найпопулярніших маршрутів

в) Уникнення подвійного малювання:
Набір drawn зберігає вже намальовані ребра як відсортовані кортежи (min, max)
Це запобігає малюванню двох напрямків ненаправленого графу

г) Відображення ваг ребер:
Вага розміщується в середині ребра синім текстом
Використовується математичне зміщення перпендикулярно до лінії ребра:
Нормальний вектор: (-dy/length, dx/length)
Зміщення на 15 пікселів від лінії для читаності

Під час кожної ітерації алгоритму реалізована плавна анімація руху мурах:

а)Плавне переміщення мурах:
Для кожної мурахи розраховується прогрес progress = frame / animation_frames
На основі прогресу визначається поточне ребро та позиція на цьому ребрі
Рівняння для плавного переміщення мурах по вершинах:

  x = x1 + (x2 - x1) * t
  y = y1 + (y2 - y1) * t
  
б) Адаптивна тривалість:
Якщо мурахи знайшли цикл: 300 кадрів (5 секунд при 60 FPS)
Якщо цикл не знайдено: 120 кадрів (2 секунди)
Це дозволяє швидше переходити до наступної ітерації при невдачах

в) Відображення мурах:
Мурахи показуються червоними кружками (радіус 8px) під час ітерацій
Червоний колір контрастує з чорними вершинами та зеленими ребрами

5. Інформаційний дисплей
На кожному кадрі відображається поточна ітерація алгоритму білим текстом (шрифт 40pt) у верхньому лівому куту. Це дозволяє користувачеві стежити за прогресом алгоритму.

7. Фінальна анімація оптимального маршруту
Після завершення всіх ітерацій запускається друга частна візуалізації:
а) Виділення оптимального шляху:
Найкращий знайдений маршрут малюється золотистою лінією (товщина 7px)
Золотистий колір (255, 215, 0) добре помітний на білому тлі й відрізняється від феромонових ребер

б)Анімація мурах:
5 мурах рухаються вздовж оптимального маршруту в циклічному режимі
Кожна мураха має свій тимчасовий зміщення t = random.random() для несинхронного руху.

При досягненні кінця маршруту мураха повертається на початок

Також, встановлено FPS-обмеження на 60 кадрів за секунду через clock.tick(60)
  




